<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客开张：记录我的后端开发的思考与成长</title>
    <url>/2024/11/03/2024-11-03-my-first-blog-post/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天是我开始写博客的第一天（终于下定决心了！）。作为一名后端开发学习者，我决定用这个博客记录我在开发过程中的思考、踩过的坑以及收获。虽然不知道能坚持多久，但至少先开始吧 😅</p>
<h2 id="为什么要写博客？"><a href="#为什么要写博客？" class="headerlink" title="为什么要写博客？"></a>为什么要写博客？</h2><ol>
<li><strong>知识沉淀</strong>：把零散的知识点整理成体系化的文章</li>
<li><strong>问题复盘</strong>：记录debug过程，下次遇到类似问题能快速定位</li>
<li><strong>技术成长</strong>：通过写作加深对技术的理解</li>
<li><strong>分享交流</strong>：希望能帮助到遇到同样问题的开发者</li>
</ol>
<h2 id="博客内容规划"><a href="#博客内容规划" class="headerlink" title="博客内容规划"></a>博客内容规划</h2><p>这个博客主要会记录：</p>
<ul>
<li><strong>后端开发思考</strong>：架构设计、性能优化、代码质量等</li>
<li><strong>Debug经验</strong>：实际项目中遇到的问题和解决方案</li>
<li><strong>技术学习</strong>：学习新技术的心得和总结</li>
<li><strong>踩坑记录</strong>：那些让人头疼的bug和解决方案</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>希望这个博客能见证我的技术成长，也希望能为其他开发者提供一些参考（虽然现在还是个菜鸟哈哈哈）。</p>
<p>路漫漫其修远兮，吾将上下而求索。</p>
<p>PS: 如果文章有错误，欢迎指正！毕竟还在学习中，难免会有理解不到位的地方 😊</p>
]]></content>
      <categories>
        <category>随便说说</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>用户中心项目踩坑记 1 ：密码加密那些事儿</title>
    <url>/2024/11/15/2024-11-15-password-security/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我做的第一个项目。前几天我对安全的理解只停留在“别写出 bug 就行”。直到在测试数据库时，亲眼看到 <code>user_password</code> 字段里躺着一串串明文密码，才想起之前刷到的视频里一句话：“明文密码 &#x3D; 红线”。本文记录我从明文存储到使用 BCrypt 的全过程，留给也在苦苦写项目的同学做参考。</p>
<h2 id="问题爆发：数据库里的“裸奔”密码"><a href="#问题爆发：数据库里的“裸奔”密码" class="headerlink" title="问题爆发：数据库里的“裸奔”密码"></a>问题爆发：数据库里的“裸奔”密码</h2><p>项目初期我只想先跑通流程，直接把前端传来的密码丢进数据库。控制层代码大概是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范，请勿模仿</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.getPassword().length() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;密码长度不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    userMapper.insert(user); <span class="comment">// 直接存明文</span></span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我用 Navicat 打开数据表，<code>&quot;12345678&quot;</code>、<code>&quot;abcdefg&quot;</code> 等弱密码全在里面。此刻我才意识到：如果数据库被拖库，所有用户账号都会暴露。</p>
<h2 id="解决过程：BCrypt-的救赎"><a href="#解决过程：BCrypt-的救赎" class="headerlink" title="解决过程：BCrypt 的救赎"></a>解决过程：BCrypt 的救赎</h2><h3 id="1-选型"><a href="#1-选型" class="headerlink" title="1. 选型"></a>1. 选型</h3><p>查资料后锁定几个常见方案：</p>
<ul>
<li><code>MD5</code>：不可逆，但彩虹表和 GPU 暴力破解太快；</li>
<li><code>SHA</code>：同样属于快速哈希，对密码保护不够；</li>
<li><code>BCrypt</code>：自带盐值，计算慢，可拖慢暴力破解。</li>
</ul>
<p>结合 Spring 生态，我直接使用 <code>BCryptPasswordEncoder</code>，不必自己维护盐值，整合也很顺。</p>
<h3 id="2-代码改造"><a href="#2-代码改造" class="headerlink" title="2. 代码改造"></a>2. 代码改造</h3><p><strong>引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注册加密 Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改造注册 &#x2F; 登录逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> passwordEncoder.encode(user.getPassword());</span><br><span class="line">        user.setPassword(encodedPassword);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-新坑：字段长度不够"><a href="#3-新坑：字段长度不够" class="headerlink" title="3. 新坑：字段长度不够"></a>3. 新坑：字段长度不够</h3><p>BCrypt 生成的哈希大约 60 个字符，而我的 <code>user_password</code> 是 <code>varchar(50)</code>。插入时报错，只能赶紧迁表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> <span class="keyword">user</span></span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> user_password <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;密码哈希&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次踩坑的收获：</p>
<ul>
<li>明文密码绝对不能入库，BCrypt 是上手友好的方案；</li>
<li>哈希字符串会更长，库表字段要预留空间；</li>
<li>善用框架提供的工具，别重复造轮子。</li>
</ul>
<p>下一篇我应该还会记录在这个项目遇到的其他问题，希望还能坚持写下去，欢迎催更！</p>
<hr>
<h2 id="更新-–-相关文章"><a href="#更新-–-相关文章" class="headerlink" title="更新 – 相关文章"></a>更新 – 相关文章</h2><p>这个用户中心项目系列的其他文章：</p>
<ul>
<li><a href="/2024/11/20/2024-11-20-login-session/">用户中心项目踩坑记 2：登录态管理的那些坑</a></li>
<li><a href="/2024/11/26/2024-11-26-user-center-database-design/">用户中心项目的数据库设计：常见问题与解决方案</a></li>
<li><a href="/2024/11/29/2024-11-29-user-center-project-summary/">用户中心项目总结：从 0 到 1 的完整实践</a></li>
</ul>
]]></content>
      <categories>
        <category>Debug 经验</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>BCrypt</tag>
        <tag>Spring Boot</tag>
        <tag>用户中心</tag>
      </tags>
  </entry>
  <entry>
    <title>用户中心项目踩坑记 2 ：登录态管理的那些坑</title>
    <url>/2024/11/20/2024-11-20-login-session/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目又又又有问题，浏览器刷新一下就得重新登录，手机和电脑也无法共享状态。作为一个大二学生，只能说完全就是啥也不会，只能一点点地查资料。本文记录我如何把零散的 Session 改成基于 Redis 的 Token 方案，希望给也在自学的同学一点参考。</p>
<h2 id="问题现象：登录态“稍纵即逝”"><a href="#问题现象：登录态“稍纵即逝”" class="headerlink" title="问题现象：登录态“稍纵即逝”"></a>问题现象：登录态“稍纵即逝”</h2><p>最开始我直接用 Spring Boot 自带的 <code>HttpSession</code> 保存用户对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginRequest request, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(request.getAccount(), request.getPassword());</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user); <span class="comment">// 明明存了，但总丢</span></span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随之暴露了三个痛点：</p>
<ol>
<li>前端用 React，刷新页面后 Session 丢失，用户得重新登录（本地两个浏览器窗口就能稳定复现）；</li>
<li>我重启后端服务，所有用户全被踢下线（开发环境重启一次就得重新登录一遍）；</li>
<li>同一账号 PC 登录后，手机端完全感知不到状态（我用同一 Wi-Fi 下的手机访问本地调试地址验证的）。</li>
</ol>
<h2 id="解决过程：Redis-Token"><a href="#解决过程：Redis-Token" class="headerlink" title="解决过程：Redis + Token"></a>解决过程：Redis + Token</h2><h3 id="1-技术选型"><a href="#1-技术选型" class="headerlink" title="1. 技术选型"></a>1. 技术选型</h3><p>我调研了三种方案：</p>
<ul>
<li><strong>原生 Session</strong>：依赖单机内存，重启或多实例时会混乱；</li>
<li><strong>JWT</strong>：无状态但无法主动失效，对我现在的需求来说不好控制；</li>
<li><strong>Redis + Token</strong>：登录后生成 Token，把用户信息放到 Redis，可控可失效，还能扩展到多节点。</li>
</ul>
<p>综合复杂度和可维护性，我选择第三种。</p>
<h3 id="2-引入-Redis-依赖"><a href="#2-引入-Redis-依赖" class="headerlink" title="2. 引入 Redis 依赖"></a>2. 引入 Redis 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-配置-Redis-连接"><a href="#3-配置-Redis-连接" class="headerlink" title="3. 配置 Redis 连接"></a>3. 配置 Redis 连接</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>本地用 Docker 起了一个 Redis，正式环境也能直接复用配置。</p>
<h3 id="4-Token-工具类"><a href="#4-Token-工具类" class="headerlink" title="4. Token 工具类"></a>4. Token 工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;USER_TOKEN:&quot;</span> + UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">storeToken</span><span class="params">(String token, UserDTO user)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(token,</span><br><span class="line">                JSON.toJSONString(user),</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">verifyToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(token);</span><br><span class="line">        <span class="keyword">if</span> (userJson == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.expire(token, <span class="number">2</span>, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(userJson, UserDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在这里刻意用了 <code>UserDTO</code>，把密码哈希等敏感字段去掉，避免 Redis 里存全量对象。虽然暂时还没部署，但趁早把敏感字段剥离掉也能避免后面迁移时手忙脚乱。</p>
<h3 id="5-改造登录接口"><a href="#5-改造登录接口" class="headerlink" title="5. 改造登录接口"></a>5. 改造登录接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginRequest request)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(request.getAccount(), request.getPassword());</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">safeUser</span> <span class="operator">=</span> UserConvertor.toDTO(user);</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenUtils.generateToken(user.getId());</span><br><span class="line">    tokenUtils.storeToken(token, safeUser);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="keyword">new</span> <span class="title class_">LoginResponse</span>(token, safeUser));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端拿到 Token 后写入 <code>localStorage</code>，请求时放到 <code>Authorization</code> 头里。现阶段只是我自己在浏览器里调试，但等以后部署到测试环境只需要把基址调一下就能继续沿用。</p>
<h3 id="6-拦截器校验登录态"><a href="#6-拦截器校验登录态" class="headerlink" title="6. 拦截器校验登录态"></a>6. 拦截器校验登录态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenUtils tokenUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> tokenUtils.verifyToken(token);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;登录已过期&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        UserContext.set(user); <span class="comment">// ThreadLocal 保存，方便后续获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>WebMvcConfigurer</code> 里把拦截器注册到需要鉴权的接口即可。</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ul>
<li><strong>Token 传递方式</strong>：最早放在 URL 查询参数，刷新和复制链接都会泄露，最后改成 <code>Authorization</code> 头；</li>
<li><strong>Redis 序列化</strong>：默认 <code>JdkSerializationRedisSerializer</code> 让 Key 出现乱码，我统一改用 <code>StringRedisTemplate</code> + JSON；</li>
<li><strong>主动下线</strong>：<code>verifyToken</code> 失败时直接抛异常，这样用户在别的设备登录会触发旧 Token 失效；</li>
<li><strong>超时续期</strong>：每次验证成功后刷新过期时间，用户只要活跃就不会被踢。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次查了不少资料让我理解了”登录态&#x3D;如何安全记住用户”。原生 Session 在单机调试还行，但遇到多端、多实例就力不从心，更别说以后上线部署（可能有吧 。Redis + Token 虽然多写了点代码，却解决了刷新、重启、分布式和主动失效的问题。下一篇正常还会继续记录这个项目，也算是督促自己进步了，希望还能坚持写下去。</p>
<hr>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>这个用户中心项目系列的其他文章：</p>
<ul>
<li><a href="/2024/11/15/2024-11-15-password-security/">用户中心项目踩坑记 1：密码加密那些事儿</a></li>
<li><a href="/2024/11/26/2024-11-26-user-center-database-design/">用户中心项目的数据库设计：常见问题与解决方案</a></li>
<li><a href="/2024/11/29/2024-11-29-user-center-project-summary/">用户中心项目总结：从 0 到 1 的完整实践</a></li>
</ul>
]]></content>
      <categories>
        <category>Debug 经验</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>用户中心</tag>
        <tag>Session</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建个人博客：Hexo + Butterfly</title>
    <url>/2024/11/21/2024-11-21-building-my-blog-with-hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想搭建一个个人博客，记录自己的技术成长和思考（主要是想有个地方记录踩过的坑，免得下次又忘了 😂）。经过一番调研，最终选择了 Hexo + Butterfly 主题。这篇文章记录一下搭建过程和一些踩坑经历（真的踩了好多坑…）。</p>
<h2 id="为什么选择-Hexo？"><a href="#为什么选择-Hexo？" class="headerlink" title="为什么选择 Hexo？"></a>为什么选择 Hexo？</h2><h3 id="1-静态站点生成器"><a href="#1-静态站点生成器" class="headerlink" title="1. 静态站点生成器"></a>1. 静态站点生成器</h3><p>Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown 编写文章，然后生成静态 HTML 文件。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>速度快</strong>：静态文件，访问速度快</li>
<li><strong>SEO友好</strong>：静态HTML，搜索引擎容易索引</li>
<li><strong>免费托管</strong>：可以部署到 GitHub Pages、Netlify 等免费平台</li>
<li><strong>版本控制</strong>：文章用 Markdown 编写，可以用 Git 管理</li>
</ul>
<h3 id="2-丰富的主题"><a href="#2-丰富的主题" class="headerlink" title="2. 丰富的主题"></a>2. 丰富的主题</h3><p>Hexo 有丰富的主题生态，我选择了 Butterfly 主题，因为：</p>
<ul>
<li><strong>界面美观</strong>：现代化的设计风格</li>
<li><strong>功能丰富</strong>：支持代码高亮、搜索、评论等</li>
<li><strong>文档完善</strong>：中文文档详细，配置简单</li>
<li><strong>持续更新</strong>：社区活跃，问题能及时解决</li>
</ul>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Node.js（需要 12.0 以上版本）</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2. 初始化项目"></a>2. 初始化项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建博客目录</span></span><br><span class="line">hexo init ahzlll.github.io</span><br><span class="line"><span class="built_in">cd</span> ahzlll.github.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-Butterfly-主题"><a href="#3-安装-Butterfly-主题" class="headerlink" title="3. 安装 Butterfly 主题"></a>3. 安装 Butterfly 主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装主题</span></span><br><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装主题依赖</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>

<h3 id="4-配置主题"><a href="#4-配置主题" class="headerlink" title="4. 配置主题"></a>4. 配置主题</h3><p>修改 <code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 站点配置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Ahzlll&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;后端开发思考&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;用代码编织梦想，用文字记录成长，偶尔记录下踩过的坑和收获&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Ahz</span> <span class="string">Hong</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题配置</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL配置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://ahzlll.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure>

<h3 id="5-本地预览"><a href="#5-本地预览" class="headerlink" title="5. 本地预览"></a>5. 本地预览</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动本地服务器</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 http://localhost:4000</span></span><br></pre></td></tr></table></figure>

<h2 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h2><h3 id="1-中文路径问题"><a href="#1-中文路径问题" class="headerlink" title="1. 中文路径问题"></a>1. 中文路径问题</h3><p><strong>问题</strong>：文章标题包含中文时，生成的URL包含中文，可能导致404。</p>
<p><strong>解决</strong>：在 <code>_config.yml</code> 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>或者使用英文标题，在文章中使用 <code>title</code> 字段。</p>
<h3 id="2-图片路径问题"><a href="#2-图片路径问题" class="headerlink" title="2. 图片路径问题"></a>2. 图片路径问题</h3><p><strong>问题</strong>：Markdown 中的图片路径不正确。</p>
<p><strong>解决</strong>：使用 Hexo 的资源文件夹功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后在文章中：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">图片名称.jpg</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-代码高亮问题"><a href="#3-代码高亮问题" class="headerlink" title="3. 代码高亮问题"></a>3. 代码高亮问题</h3><p><strong>问题</strong>：代码高亮不生效。</p>
<p><strong>解决</strong>：安装代码高亮插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-prism-plugin --save</span><br></pre></td></tr></table></figure>

<p>在 <code>_config.yml</code> 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">&#x27;preprocess&#x27;</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">custom_css:</span></span><br></pre></td></tr></table></figure>

<h3 id="4-搜索功能"><a href="#4-搜索功能" class="headerlink" title="4. 搜索功能"></a>4. 搜索功能</h3><p><strong>问题</strong>：本地搜索不工作。</p>
<p><strong>解决</strong>：安装搜索插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">xml</span></span><br></pre></td></tr></table></figure>

<h3 id="5-部署到-GitHub-Pages"><a href="#5-部署到-GitHub-Pages" class="headerlink" title="5. 部署到 GitHub Pages"></a>5. 部署到 GitHub Pages</h3><p><strong>问题</strong>：部署后样式丢失。</p>
<p><strong>解决</strong>：检查 <code>_config.yml</code> 中的 <code>url</code> 配置，确保与 GitHub Pages 地址一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://ahzlll.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<h2 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h2><h3 id="1-添加友链"><a href="#1-添加友链" class="headerlink" title="1. 添加友链"></a>1. 添加友链</h3><p>创建 <code>source/_data/link.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">技术博客</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">分享技术心得和开发经验的优秀博客</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://hexo.io/favicon.ico</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简洁且高效的博客框架</span></span><br></pre></td></tr></table></figure>

<h3 id="2-自定义样式"><a href="#2-自定义样式" class="headerlink" title="2. 自定义样式"></a>2. 自定义样式</h3><p>创建 <code>source/css/custom-green-theme.css</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义样式 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--theme-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主题配置中引入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom-green-theme.css&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加统计"><a href="#3-添加统计" class="headerlink" title="3. 添加统计"></a>3. 添加统计</h3><p>使用不蒜子统计：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="写作体验"><a href="#写作体验" class="headerlink" title="写作体验"></a>写作体验</h2><h3 id="1-Markdown-编写"><a href="#1-Markdown-编写" class="headerlink" title="1. Markdown 编写"></a>1. Markdown 编写</h3><p>使用 Markdown 编写文章，简单高效：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2024-11-21 20:00:00</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> 标签1</span><br><span class="line"><span class="bullet">  -</span> 标签2</span><br><span class="line">categories:</span><br><span class="line"><span class="section">  - 分类</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 标题</span></span><br><span class="line"></span><br><span class="line">正文内容...</span><br></pre></td></tr></table></figure>

<h3 id="2-代码高亮"><a href="#2-代码高亮" class="headerlink" title="2. 代码高亮"></a>2. 代码高亮</h3><p>支持多种语言的代码高亮：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```java</span></span><br><span class="line"><span class="code">public class Hello &#123;</span></span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<h3 id="3-数学公式"><a href="#3-数学公式" class="headerlink" title="3. 数学公式"></a>3. 数学公式</h3><p>支持 LaTeX 数学公式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">E = mc^2</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><h3 id="1-生成静态文件"><a href="#1-生成静态文件" class="headerlink" title="1. 生成静态文件"></a>1. 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="2-部署到-GitHub-Pages"><a href="#2-部署到-GitHub-Pages" class="headerlink" title="2. 部署到 GitHub Pages"></a>2. 部署到 GitHub Pages</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/ahzlll/ahzlll.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h3 id="3-自动化部署"><a href="#3-自动化部署" class="headerlink" title="3. 自动化部署"></a>3. 自动化部署</h3><p>可以使用 GitHub Actions 实现自动化部署：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>写作简单</strong>：Markdown 语法，专注内容</li>
<li><strong>部署方便</strong>：一键部署到 GitHub Pages</li>
<li><strong>主题丰富</strong>：Butterfly 主题功能完善</li>
<li><strong>性能优秀</strong>：静态站点，访问速度快</li>
<li><strong>SEO友好</strong>：搜索引擎容易索引</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>需要本地环境</strong>：需要安装 Node.js</li>
<li><strong>更新需要重新生成</strong>：每次更新需要重新生成静态文件</li>
<li><strong>评论功能</strong>：需要第三方服务（如 Valine、Gitalk）</li>
</ol>
<h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><ol>
<li><strong>内容优化</strong>：持续输出高质量的技术文章</li>
<li><strong>功能完善</strong>：添加评论、搜索等功能</li>
<li><strong>性能优化</strong>：优化加载速度，提升用户体验</li>
<li><strong>SEO优化</strong>：提升搜索引擎排名</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>搭建个人博客是一个很好的学习过程，不仅能记录技术成长，还能锻炼写作能力。Hexo + Butterfly 是一个很好的选择，简单易用，功能丰富。</p>
<p>如果你也想搭建个人博客，可以参考我的配置：</p>
<ul>
<li>博客地址：<a href="https://ahzlll.github.io/">https://ahzlll.github.io</a></li>
<li>项目地址：<a href="https://github.com/ahzlll/ahzlll.github.io">https://github.com/ahzlll/ahzlll.github.io</a></li>
</ul>
<hr>
<p><strong>写在最后</strong>：博客搭建只是第一步，更重要的是持续输出有价值的内容（虽然不知道能坚持多久 😅）。希望自己能坚持下去，记录技术成长，分享开发经验。如果文章有错误，欢迎指正！</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>用户中心项目的数据库设计：常见问题与解决方案</title>
    <url>/2024/11/26/2024-11-26-user-center-database-design/</url>
    <content><![CDATA[<p>用户中心是几乎所有 Web 应用的核心模块，负责用户注册、登录、信息管理等关键功能。我在学习后端开发时发现，设计一个用户中心的数据库并不像想象中那么简单。今天想和大家分享一些我在学习过程中遇到的问题，以及找到的解决方案。虽然我还在学习中，但这些经验希望能帮助到同样刚入门的朋友们。</p>
<h2 id="一、用户表设计的核心问题"><a href="#一、用户表设计的核心问题" class="headerlink" title="一、用户表设计的核心问题"></a>一、用户表设计的核心问题</h2><h3 id="1-主键选择困境"><a href="#1-主键选择困境" class="headerlink" title="1. 主键选择困境"></a>1. 主键选择困境</h3><p><strong>问题描述</strong>：刚开始设计用户表时，我遇到了第一个问题：用户 ID 应该用什么类型？是自增的整数（1, 2, 3…）还是 UUID（一串随机字符）？用 INT 还是 BIGINT？</p>
<p><strong>解决方案</strong>：</p>
<p>对于初学者来说，我建议先用 <code>INT AUTO_INCREMENT</code>，原因很简单：</p>
<ul>
<li><strong>简单易懂</strong>：数据库会自动帮你生成 1, 2, 3… 这样的 ID</li>
<li><strong>查询快</strong>：整数比较比字符串快很多</li>
<li><strong>够用了</strong>：INT 类型最大可以存到 21 亿多，对于学习项目完全够用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  <span class="comment">-- 其他字段...</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>我的理解</strong>：就像给每个学生分配学号一样，自增 ID 简单直接。除非你的应用真的需要支持超过 21 亿用户（这几乎不可能），否则不需要用 BIGINT。UUID 虽然能隐藏用户数量，但会让查询变慢，初学者不建议使用。</p>
<h3 id="2-多登录方式的兼容问题"><a href="#2-多登录方式的兼容问题" class="headerlink" title="2. 多登录方式的兼容问题"></a>2. 多登录方式的兼容问题</h3><p><strong>问题描述</strong>：现在的应用通常支持用户名、手机号、邮箱甚至第三方账号（微信、QQ）登录。刚开始我直接把所有字段都塞到用户表里，结果表变得特别乱。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>主表放常用字段</strong>：用户名、邮箱、手机号这些常用的登录方式放在主表</li>
<li><strong>第三方登录单独放</strong>：微信、QQ 这些第三方登录信息放在另一个表，用 <code>user_id</code> 关联起来</li>
<li><strong>用 UNIQUE 保证唯一</strong>：确保每个邮箱、手机号只能注册一次</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 主用户表（存放基本信息）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `password_hash` <span class="type">CHAR</span>(<span class="number">60</span>) COMMENT <span class="string">&#x27;密码哈希(bcrypt)&#x27;</span>,</span><br><span class="line">  `status` ENUM(<span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;banned&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;inactive&#x27;</span>,</span><br><span class="line">  `created_at` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  INDEX `idx_email` (`email`),    <span class="comment">-- 给邮箱建索引，登录时查得快</span></span><br><span class="line">  INDEX `idx_phone` (`phone`)     <span class="comment">-- 给手机号建索引，登录时查得快</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户基本信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三方登录关联表（存放微信、QQ等登录信息）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_oauth` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `provider` ENUM(<span class="string">&#x27;wechat&#x27;</span>, <span class="string">&#x27;qq&#x27;</span>, <span class="string">&#x27;github&#x27;</span>, <span class="string">&#x27;google&#x27;</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;登录方式&#x27;</span>,</span><br><span class="line">  `provider_user_id` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;第三方平台的用户ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_provider_user` (`provider`, `provider_user_id`)</span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;第三方登录关联表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>简单解释</strong>：</p>
<ul>
<li><code>UNIQUE</code>：保证这个字段的值不能重复（比如不能有两个相同的邮箱）</li>
<li><code>INDEX</code>：索引就像书的目录，能让你快速找到想要的数据</li>
<li><code>FOREIGN KEY</code>：外键，保证 <code>user_oauth</code> 表中的 <code>user_id</code> 必须在 <code>user</code> 表中存在</li>
<li><code>ON DELETE CASCADE</code>：如果用户被删除了，相关的第三方登录信息也会自动删除</li>
</ul>
<h2 id="二、用户信息管理的挑战"><a href="#二、用户信息管理的挑战" class="headerlink" title="二、用户信息管理的挑战"></a>二、用户信息管理的挑战</h2><h3 id="1-用户资料的扩展性问题"><a href="#1-用户资料的扩展性问题" class="headerlink" title="1. 用户资料的扩展性问题"></a>1. 用户资料的扩展性问题</h3><p><strong>问题描述</strong>：刚开始我只在用户表里放了用户名和密码，后来想加头像、性别、生日…每次都要改表结构，特别麻烦。而且如果以后还要加更多字段，表会变得越来越大。</p>
<p><strong>解决方案</strong>：</p>
<p>我的做法是分表存储：</p>
<ul>
<li><strong>主表放核心信息</strong>：用户名、密码这些登录必需的信息</li>
<li><strong>扩展表放详细信息</strong>：头像、性别、生日这些放在另一个表</li>
<li><strong>动态属性表</strong>：如果以后还要加一些不常用的字段，可以用键值对的方式存储</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户扩展信息表（存放头像、性别、生日等）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_profile` (</span><br><span class="line">  `profile_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `avatar_url` <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;头像URL&#x27;</span>,</span><br><span class="line">  `gender` ENUM(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;unknown&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `birthday` <span class="type">DATE</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  `bio` TEXT COMMENT <span class="string">&#x27;个人简介&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_id` (`user_id`)  <span class="comment">-- 一个用户只有一条资料</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户详细资料表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态属性表（如果以后要加一些不常用的字段，可以用这个表）</span></span><br><span class="line"><span class="comment">-- 比如：用户喜欢的颜色、座右铭等，不需要单独建字段</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_attribute` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `attr_key` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;属性名，比如&quot;favorite_color&quot;&#x27;</span>,</span><br><span class="line">  `attr_value` TEXT COMMENT <span class="string">&#x27;属性值，比如&quot;蓝色&quot;&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_attr` (`user_id`, `attr_key`)  <span class="comment">-- 一个用户的同一个属性只能有一条</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户动态属性表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要分表？</strong></p>
<ul>
<li>主表查询频繁（登录时要用），字段少查询快</li>
<li>扩展信息不常查询，分开存储不会影响登录性能</li>
<li>以后要加新字段，只需要改扩展表，不用动主表</li>
</ul>
<h3 id="2-隐私设置的灵活控制"><a href="#2-隐私设置的灵活控制" class="headerlink" title="2. 隐私设置的灵活控制"></a>2. 隐私设置的灵活控制</h3><p><strong>问题描述</strong>：有些用户希望手机号只有自己能看到，有些用户希望生日对好友可见。如果每个隐私设置都单独建字段，会很麻烦。</p>
<p><strong>解决方案</strong>：用一个独立的隐私设置表，可以灵活控制每个字段的可见性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `user_privacy` (</span><br><span class="line">  `privacy_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `field` ENUM(<span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>, <span class="string">&#x27;birthday&#x27;</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;要设置隐私的字段&#x27;</span>,</span><br><span class="line">  `visibility` ENUM(<span class="string">&#x27;public&#x27;</span>, <span class="string">&#x27;friends&#x27;</span>, <span class="string">&#x27;private&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;private&#x27;</span> COMMENT <span class="string">&#x27;可见性：公开/仅好友/仅自己&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_field` (`user_id`, `field`)  <span class="comment">-- 一个用户的同一个字段只能有一条设置</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户隐私设置表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong>：</p>
<ul>
<li>用户A设置手机号为 <code>private</code>（仅自己可见）</li>
<li>用户B设置生日为 <code>friends</code>（仅好友可见）</li>
<li>用户C设置个人资料为 <code>public</code>（所有人可见）</li>
</ul>
<h2 id="三、性能与安全优化"><a href="#三、性能与安全优化" class="headerlink" title="三、性能与安全优化"></a>三、性能与安全优化</h2><h3 id="1-登录性能优化"><a href="#1-登录性能优化" class="headerlink" title="1. 登录性能优化"></a>1. 登录性能优化</h3><p><strong>问题描述</strong>：登录是用户最常用的功能，如果每次登录都要等很久，用户体验会很差。刚开始我的表没有建索引，登录时数据库要扫描整个表，特别慢。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>建索引</strong>：给邮箱、手机号这些登录字段建索引，就像给书加目录，查起来快很多</li>
<li><strong>用缓存</strong>：登录成功后把用户信息存到 Redis，下次查询直接从缓存取，不用查数据库</li>
<li><strong>记录登录日志</strong>：记录每次登录的信息，方便以后分析（比如发现异常登录）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 登录日志表（记录每次登录的信息，方便以后分析）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_login_log` (</span><br><span class="line">  `log_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `login_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;登录时间&#x27;</span>,</span><br><span class="line">  `ip_address` <span class="type">VARCHAR</span>(<span class="number">45</span>) COMMENT <span class="string">&#x27;IP地址（可以用来发现异常登录）&#x27;</span>,</span><br><span class="line">  `user_agent` TEXT COMMENT <span class="string">&#x27;客户端信息（用的什么浏览器、什么设备）&#x27;</span>,</span><br><span class="line">  `login_result` ENUM(<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;fail&#x27;</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;登录结果：成功/失败&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  INDEX `idx_user_time` (`user_id`, `login_time`)  <span class="comment">-- 按用户和时间查日志时用</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户登录日志表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>基于 Redis 的 Token 方案</strong>（如果还没学 Redis，可以先跳过这部分）：</p>
<p>我使用了基于 Redis 的 Token 方案来管理登录态（详细实现见<a href="/2024/11/20/2024-11-20-login-session/">《用户中心项目踩坑记 2：登录态管理的那些坑》</a>）。这个方案不仅能缓存用户信息，还能解决多端登录、服务重启等问题。</p>
<p><strong>核心思路</strong>：</p>
<ul>
<li>登录成功后生成 Token，把用户信息（脱敏后的 <code>UserDTO</code>）存到 Redis</li>
<li>Token 作为 Key，用户信息作为 Value，设置 2 小时过期时间</li>
<li>每次验证 Token 时自动续期，用户只要活跃就不会被踢下线</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 Token（格式：USER_TOKEN:随机UUID）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;USER_TOKEN:&quot;</span> + UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 Token 和用户信息到 Redis（2小时过期）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">storeToken</span><span class="params">(String token, UserDTO user)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(token,</span><br><span class="line">                JSON.toJSONString(user),  <span class="comment">// 存储脱敏后的用户信息</span></span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 Token 并自动续期</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">verifyToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(token);</span><br><span class="line">        <span class="keyword">if</span> (userJson == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// Token 不存在或已过期</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证成功后自动续期（刷新过期时间为2小时）</span></span><br><span class="line">        redisTemplate.expire(token, <span class="number">2</span>, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(userJson, UserDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么用 Redis 而不是数据库？</strong></p>
<ul>
<li><strong>性能</strong>：Redis 是内存数据库，查询速度比 MySQL 快很多</li>
<li><strong>分布式支持</strong>：多个服务实例可以共享同一个 Redis，实现多端登录</li>
<li><strong>自动过期</strong>：Redis 支持设置过期时间，Token 到期自动删除，不用手动清理</li>
<li><strong>减轻数据库压力</strong>：登录态验证是高频操作，用 Redis 可以大大减少数据库查询</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>存储的是 <code>UserDTO</code>（脱敏后的用户信息），不要存完整的 <code>User</code> 对象（避免泄露密码哈希等敏感信息）</li>
<li>Token 验证成功后要自动续期，这样用户只要活跃就不会被踢下线</li>
<li>如果用户在其他设备登录，可以让旧 Token 失效（实现单点登录）</li>
</ul>
<p><strong>为什么需要登录日志？</strong></p>
<ul>
<li>可以分析用户登录习惯（比如什么时间登录最多）</li>
<li>发现异常登录（比如同一个账号在不同城市登录）</li>
<li>如果账号被盗，可以通过日志追踪</li>
</ul>
<h3 id="2-密码安全存储"><a href="#2-密码安全存储" class="headerlink" title="2. 密码安全存储"></a>2. 密码安全存储</h3><p><strong>问题描述</strong>：这是最重要的一点！密码绝对不能明文存储。如果数据库被泄露，明文密码会让所有用户账号都暴露。即使是用 MD5 简单哈希也不安全，因为 MD5 已经被破解了，很容易被暴力破解。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>使用 bcrypt 哈希</strong>：这是目前最安全的密码存储方式（注意：是哈希不是加密，哈希是不可逆的）</li>
<li><strong>永远不存明文</strong>：密码经过哈希后，就永远不能还原成原始密码（这是好事！）</li>
<li><strong>密码强度校验</strong>：要求用户设置强密码（至少8位，包含大小写字母和数字）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 密码历史表（防止用户改密码时，又改回之前用过的密码）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_password_history` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `password_hash` <span class="type">CHAR</span>(<span class="number">60</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;历史密码的哈希值&#x27;</span>,</span><br><span class="line">  `created_at` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;使用这个密码的时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  INDEX `idx_user_id` (`user_id`)</span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户密码历史表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要密码历史表？</strong></p>
<ul>
<li>防止用户改密码时，又改回之前用过的旧密码（不安全）</li>
<li>可以设置规则：新密码不能和最近2次用过的密码相同</li>
</ul>
<p><strong>bcrypt 的特点</strong>：</p>
<ul>
<li>哈希后的密码固定是 60 个字符</li>
<li>每次哈希同一个密码，结果都不一样（但验证时能正确匹配）</li>
<li>破解难度极高，是目前最安全的密码存储方式</li>
</ul>
<h2 id="四、常见业务场景解决方案"><a href="#四、常见业务场景解决方案" class="headerlink" title="四、常见业务场景解决方案"></a>四、常见业务场景解决方案</h2><h3 id="1-用户状态管理"><a href="#1-用户状态管理" class="headerlink" title="1. 用户状态管理"></a>1. 用户状态管理</h3><p><strong>问题描述</strong>：用户可能有不同的状态：刚注册还没激活、正常使用、被封禁、已注销。需要用一个字段来记录这些状态，而且要保证状态切换是安全的（比如不能随便封禁用户）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>用 ENUM 限制状态值</strong>：只能选择预设的几个状态，不能随便填</li>
<li><strong>记录状态变更日志</strong>：谁在什么时候把用户状态改成了什么，都要记录下来</li>
<li><strong>注销用逻辑删除</strong>：用户注销时，不直接删除数据，而是标记为”已删除”，这样数据还能恢复</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在用户表添加状态字段</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `status` ENUM(<span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;banned&#x27;</span>, <span class="string">&#x27;deleted&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="comment">-- pending: 待激活（刚注册，还没验证邮箱/手机）</span></span><br><span class="line"><span class="comment">-- active: 正常使用</span></span><br><span class="line"><span class="comment">-- banned: 被封禁（违规了）</span></span><br><span class="line"><span class="comment">-- deleted: 已注销（用户自己注销的）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 状态变更日志（记录每次状态变化）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_status_log` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `old_status` ENUM(<span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;banned&#x27;</span>, <span class="string">&#x27;deleted&#x27;</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;旧状态&#x27;</span>,</span><br><span class="line">  `new_status` ENUM(<span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;banned&#x27;</span>, <span class="string">&#x27;deleted&#x27;</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;新状态&#x27;</span>,</span><br><span class="line">  `operated_by` <span class="type">INT</span> COMMENT <span class="string">&#x27;操作人ID（哪个管理员操作的）&#x27;</span>,</span><br><span class="line">  `operate_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `reason` TEXT COMMENT <span class="string">&#x27;变更原因（为什么要封禁这个用户）&#x27;</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户状态变更日志&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要记录日志？</strong></p>
<ul>
<li>如果管理员误操作，可以通过日志恢复</li>
<li>如果用户申诉，可以查看历史记录</li>
<li>方便审计，知道谁在什么时候做了什么操作</li>
</ul>
<h3 id="2-权限与角色管理"><a href="#2-权限与角色管理" class="headerlink" title="2. 权限与角色管理"></a>2. 权限与角色管理</h3><p><strong>问题描述</strong>：如果系统有管理员、普通用户、VIP 用户等不同角色，每个角色能做的事情不一样。如果给每个用户单独设置权限，会很麻烦。比如有 1000 个普通用户，难道要设置 1000 次吗？</p>
<p><strong>解决方案</strong>：采用 RBAC（基于角色的访问控制）模型。简单说就是：先定义角色（管理员、普通用户），再给角色分配权限，最后把用户分配给角色。这样管理起来方便很多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 角色表（定义有哪些角色：管理员、普通用户、VIP等）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `role` (</span><br><span class="line">  `role_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `role_name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `description` TEXT COMMENT <span class="string">&#x27;角色描述&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户角色关联表（哪个用户属于哪个角色）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `role_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>`(`user_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`role_id`) <span class="keyword">REFERENCES</span> `role`(`role_id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_role` (`user_id`, `role_id`)  <span class="comment">-- 一个用户不能重复分配同一个角色</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 权限表（定义有哪些权限：删除文章、封禁用户等）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `permission` (</span><br><span class="line">  `perm_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `perm_code` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;权限代码，比如&quot;article:delete&quot;&#x27;</span>,</span><br><span class="line">  `description` TEXT COMMENT <span class="string">&#x27;权限描述&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;权限表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色权限关联表（哪个角色有哪些权限）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `role_permission` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `perm_id` <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`role_id`) <span class="keyword">REFERENCES</span> `role`(`role_id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (`perm_id`) <span class="keyword">REFERENCES</span> `permission`(`perm_id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_perm` (`role_id`, `perm_id`)  <span class="comment">-- 一个角色不能重复分配同一个权限</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;角色权限关联表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong>：</p>
<ol>
<li>创建角色：管理员、普通用户</li>
<li>给管理员分配权限：删除文章、封禁用户、查看所有数据</li>
<li>给普通用户分配权限：发布文章、评论</li>
<li>把用户A分配给”管理员”角色，用户B分配给”普通用户”角色</li>
</ol>
<p>这样，用户A自动拥有管理员的权限，用户B自动拥有普通用户的权限。如果以后要给普通用户增加新权限，只需要在 <code>role_permission</code> 表里加一条记录，所有普通用户就都有这个权限了。</p>
<h2 id="五、设计原则总结"><a href="#五、设计原则总结" class="headerlink" title="五、设计原则总结"></a>五、设计原则总结</h2><p>作为初学者，我总结了几个重要的设计原则（不知道有没有什么问题 QAQ：</p>
<ol>
<li><strong>安全性优先</strong>：密码必须哈希存储（用 bcrypt），敏感信息要脱敏，重要操作要记录日志</li>
<li><strong>不要过度设计</strong>：刚开始不需要考虑太多，先实现基本功能，等真正遇到问题再优化</li>
<li><strong>分表存储</strong>：核心信息（登录用的）和扩展信息（个人资料）分开，这样查询更快</li>
<li><strong>合理建索引</strong>：给经常查询的字段（邮箱、手机号）建索引，但不要建太多（会影响写入性能）</li>
<li><strong>预留扩展空间</strong>：设计时想想以后可能会加什么功能，但不要想太多（容易过度设计）</li>
<li><strong>保证数据一致性</strong>：用外键、唯一索引、事务来保证数据不会出错</li>
</ol>
<hr>
<h2 id="六、学习感想"><a href="#六、学习感想" class="headerlink" title="六、学习感想"></a>六、学习感想</h2><p>我在学习数据库设计的过程中踩了不少坑，也学到了很多。想和大家分享几点感受：</p>
<p><strong>1. 理论很重要，但实践更关键</strong></p>
<p>刚开始我看了很多数据库设计的理论，但真正动手设计时才发现，理论和实际差距很大。比如书上说”要避免过度设计”，但怎么判断是不是”过度”？只有真正做了项目，遇到问题，才能理解。</p>
<p><strong>2. 从简单开始，逐步优化</strong></p>
<p>我刚开始想把所有功能都设计好，结果表设计得特别复杂，后来发现很多功能根本用不到。现在我的做法是：先设计最简单的版本，能跑起来就行。等真正需要某个功能时，再加对应的表或字段。</p>
<p><strong>3. 多思考，多总结</strong></p>
<p>每次遇到问题，我都会想：为什么会这样？有没有更好的方法？然后记录下来。这篇文章就是我学习过程中的总结，希望能帮助到同样在学习的朋友。（主要也是有个博客能让我督促自己啦</p>
<p>要是你也想建一个博客，和我一样记录自己的学习，可以参考我的博客搭建方法（见<a href="/2024/11/21/2024-11-21-building-my-blog-with-hexo/">《从零开始搭建个人博客：Hexo + Butterfly 主题实践》</a>）</p>
<p><strong>4. 不要害怕犯错</strong></p>
<p>我在设计过程中犯了很多错误：表结构不合理、忘记建索引、外键设置错误…但每次犯错都是一次学习的机会。现在回头看，这些错误让我对数据库有了更深的理解。</p>
<hr>
<p><strong>写在最后</strong>：</p>
<p>数据库设计是一个需要不断学习和实践的过程。刚开始我们不需要一开始就设计出完美的系统，像我开始的时候一直东想西想，但在项目写着写着的时候还是遇到了不少问题，所以最重要的还是先实践，再从中不断改进。如果这篇文章对你有帮助，或者你发现了什么问题，欢迎一起交流讨论！</p>
<p>学习路上，我们一起加油！💪 </p>
<p><strong>一些废话</strong>：</p>
<p>写这篇博客花费了好长时间，感觉好多东西学了也用了，却不知道怎么输出给别人看，怎么梳理都还是不够好，但就这样吧 实在写不下去了，感觉比做项目还要命QAQ</p>
<hr>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>这个用户中心项目系列的其他文章：</p>
<ul>
<li><a href="/2024/11/15/2024-11-15-password-security/">用户中心项目踩坑记 1：密码加密那些事儿</a></li>
<li><a href="/2024/11/20/2024-11-20-login-session/">用户中心项目踩坑记 2：登录态管理的那些坑</a></li>
<li><a href="/2024/11/29/2024-11-29-user-center-project-summary/">用户中心项目总结：从 0 到 1 的完整实践</a></li>
</ul>
]]></content>
      <categories>
        <category>后端开发思考</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>用户中心</tag>
        <tag>Redis</tag>
        <tag>数据库设计</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员不一定知道的10个技术冷知识</title>
    <url>/2024/11/25/2024-11-25-programming-cold-knowledge/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在编程的世界里，总有一些有趣但容易被忽视的知识点。这些”冷知识”可能不会直接影响你的代码，但了解它们能让你对编程有更深的理解（而且聊天的时候可以装X 😎）。今天分享一些我觉得有趣的技术冷知识。</p>
<h2 id="1-为什么数组索引从0开始？"><a href="#1-为什么数组索引从0开始？" class="headerlink" title="1. 为什么数组索引从0开始？"></a>1. 为什么数组索引从0开始？</h2><p>这是一个经典问题。数组索引从0开始的原因有多种说法：</p>
<h3 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h3><p>在C语言中，数组名实际上是指向数组第一个元素的指针。所以 <code>arr[i]</code> 实际上等价于 <code>*(arr + i)</code>，即从数组起始地址偏移 <code>i</code> 个元素大小的位置。</p>
<p>如果从1开始，那么 <code>arr[i]</code> 就需要写成 <code>*(arr + i - 1)</code>，多了一次减法运算。</p>
<h3 id="数学原因"><a href="#数学原因" class="headerlink" title="数学原因"></a>数学原因</h3><p>从数学角度看，索引从0开始更符合”偏移量”的概念：</p>
<ul>
<li>第一个元素：偏移0个单位</li>
<li>第二个元素：偏移1个单位</li>
<li>第n个元素：偏移n-1个单位</li>
</ul>
<h3 id="实际影响"><a href="#实际影响" class="headerlink" title="实际影响"></a>实际影响</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从0开始：第i个元素的索引就是i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = i;  <span class="comment">// 简洁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果从1开始：第i个元素的索引是i-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">    arr[i-<span class="number">1</span>] = i;  <span class="comment">// 需要减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-为什么叫”Bug”？"><a href="#2-为什么叫”Bug”？" class="headerlink" title="2. 为什么叫”Bug”？"></a>2. 为什么叫”Bug”？</h2><p>1947年，哈佛大学的Mark II计算机出现故障。工程师Grace Hopper在继电器中发现了一只飞蛾，她将这只飞蛾用胶带贴在了日志本上，并标注”First actual case of bug being found”（发现bug的第一个实际案例）。</p>
<p>从此，”bug”就成了程序错误的代名词。</p>
<p>有趣的是，在Grace Hopper之前，Thomas Edison就已经用”bug”来形容技术问题了。他在1878年的一封信中写道：”It has been just so in all of my inventions. The first step is an intuition, and comes with a burst, then difficulties arise—this thing gives out and [it is] then that ‘Bugs’—as such little faults and difficulties are called—show themselves…”</p>
<h2 id="3-为什么叫”Foo”和”Bar”？"><a href="#3-为什么叫”Foo”和”Bar”？" class="headerlink" title="3. 为什么叫”Foo”和”Bar”？"></a>3. 为什么叫”Foo”和”Bar”？</h2><p>在编程示例中，我们经常看到 <code>foo</code>、<code>bar</code>、<code>baz</code> 这样的变量名。这些名字来自哪里？</p>
<h3 id="历史来源"><a href="#历史来源" class="headerlink" title="历史来源"></a>历史来源</h3><p>“Foo”可能来自二战时期的军事俚语”FUBAR”（Fucked Up Beyond All Recognition），意思是”完全搞砸了”。</p>
<p>“Bar”可能是”foo”的押韵词，或者是”beyond all recognition”的缩写。</p>
<h3 id="使用习惯"><a href="#使用习惯" class="headerlink" title="使用习惯"></a>使用习惯</h3><p>这些名字已经成为编程中的”占位符”，表示”这里应该有一个有意义的变量名，但为了示例简洁，我们用一个无意义的名称”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processFoo</span><span class="params">(Foo foo)</span> &#123;</span><br><span class="line">    <span class="type">Bar</span> <span class="variable">bar</span> <span class="operator">=</span> foo.getBar();</span><br><span class="line">    <span class="type">Baz</span> <span class="variable">baz</span> <span class="operator">=</span> bar.getBaz();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-为什么HTTP状态码是三位数？"><a href="#4-为什么HTTP状态码是三位数？" class="headerlink" title="4. 为什么HTTP状态码是三位数？"></a>4. 为什么HTTP状态码是三位数？</h2><p>HTTP状态码使用三位数字，这是有原因的：</p>
<h3 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h3><ul>
<li><p><strong>第一位数字</strong>：表示响应类别</p>
<ul>
<li>1xx：信息性响应</li>
<li>2xx：成功响应</li>
<li>3xx：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ul>
</li>
<li><p><strong>后两位数字</strong>：表示具体的错误类型</p>
</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>这种设计允许：</p>
<ul>
<li>在现有类别中添加新的状态码（如201 Created）</li>
<li>自定义状态码（虽然不推荐）</li>
<li>客户端可以根据第一位数字快速判断响应类型</li>
</ul>
<h2 id="5-为什么叫”Cookie”？"><a href="#5-为什么叫”Cookie”？" class="headerlink" title="5. 为什么叫”Cookie”？"></a>5. 为什么叫”Cookie”？</h2><p>HTTP Cookie的名字来自”magic cookie”（魔法饼干），这是Unix系统中的一个概念，指的是一小段数据，程序可以读取它，但通常不能修改。</p>
<h3 id="命名来源"><a href="#命名来源" class="headerlink" title="命名来源"></a>命名来源</h3><p>Lou Montulli在1994年发明了HTTP Cookie。他选择这个名字是因为：</p>
<ol>
<li>Cookie是”magic cookie”的简称</li>
<li>Cookie是”小甜点”，就像HTTP Cookie是”小数据片段”</li>
<li>名字简单易记</li>
</ol>
<h3 id="有趣的事实"><a href="#有趣的事实" class="headerlink" title="有趣的事实"></a>有趣的事实</h3><p>Cookie的正式名称是”HTTP State Management Mechanism”（HTTP状态管理机制），但”Cookie”这个名字更流行。</p>
<h2 id="6-为什么叫”Spam”（垃圾邮件）？"><a href="#6-为什么叫”Spam”（垃圾邮件）？" class="headerlink" title="6. 为什么叫”Spam”（垃圾邮件）？"></a>6. 为什么叫”Spam”（垃圾邮件）？</h2><p>“Spam”这个词来自Monty Python的喜剧小品，其中Spam（午餐肉罐头）在菜单上反复出现，让人厌烦。</p>
<p>后来，这个词被用来形容：</p>
<ul>
<li>垃圾邮件（Email Spam）</li>
<li>垃圾评论（Comment Spam）</li>
<li>垃圾信息（Message Spam）</li>
</ul>
<h3 id="技术含义"><a href="#技术含义" class="headerlink" title="技术含义"></a>技术含义</h3><p>在编程中，”spam”通常指：</p>
<ul>
<li>重复发送大量无意义的消息</li>
<li>恶意刷屏</li>
<li>自动化攻击</li>
</ul>
<h2 id="7-为什么叫”Daemon”（守护进程）？"><a href="#7-为什么叫”Daemon”（守护进程）？" class="headerlink" title="7. 为什么叫”Daemon”（守护进程）？"></a>7. 为什么叫”Daemon”（守护进程）？</h2><p>在Unix&#x2F;Linux系统中，后台运行的进程叫”daemon”（守护进程）。</p>
<h3 id="命名来源-1"><a href="#命名来源-1" class="headerlink" title="命名来源"></a>命名来源</h3><p>“Daemon”来自希腊神话中的”δαίμων”（daimon），指的是介于神和人之间的超自然存在，它们默默工作，不被人注意。</p>
<h3 id="技术含义-1"><a href="#技术含义-1" class="headerlink" title="技术含义"></a>技术含义</h3><p>守护进程的特点：</p>
<ul>
<li>在后台运行</li>
<li>没有控制终端</li>
<li>通常以root权限运行</li>
<li>为系统提供服务</li>
</ul>
<p>例如：<code>httpd</code>（Web服务器）、<code>mysqld</code>（数据库服务器）、<code>sshd</code>（SSH服务器）。</p>
<h2 id="8-为什么叫”Ping”？"><a href="#8-为什么叫”Ping”？" class="headerlink" title="8. 为什么叫”Ping”？"></a>8. 为什么叫”Ping”？</h2><p><code>ping</code> 命令的名字来自声纳的”ping”声。</p>
<h3 id="命名来源-2"><a href="#命名来源-2" class="headerlink" title="命名来源"></a>命名来源</h3><p>Mike Muuss在1983年编写了ping程序。他选择这个名字是因为：</p>
<ol>
<li>声纳发出”ping”声来探测物体</li>
<li>ping程序发送数据包来探测网络连接</li>
<li>两者都是”探测”的概念</li>
</ol>
<h3 id="技术含义-2"><a href="#技术含义-2" class="headerlink" title="技术含义"></a>技术含义</h3><p>ping的工作原理：</p>
<ol>
<li>发送ICMP Echo Request包</li>
<li>等待目标主机返回ICMP Echo Reply包</li>
<li>计算往返时间（RTT）</li>
</ol>
<h2 id="9-为什么叫”Stack-Overflow”？"><a href="#9-为什么叫”Stack-Overflow”？" class="headerlink" title="9. 为什么叫”Stack Overflow”？"></a>9. 为什么叫”Stack Overflow”？</h2><p>Stack Overflow（栈溢出）是一个著名的编程问答网站。</p>
<h3 id="技术含义-3"><a href="#技术含义-3" class="headerlink" title="技术含义"></a>技术含义</h3><p>“Stack Overflow”是一个编程术语，指的是：</p>
<ul>
<li>当程序调用栈超出可用内存时</li>
<li>会导致程序崩溃</li>
<li>是一个常见的编程错误</li>
</ul>
<h3 id="网站命名"><a href="#网站命名" class="headerlink" title="网站命名"></a>网站命名</h3><p>网站创始人选择这个名字是因为：</p>
<ol>
<li>这是一个程序员都熟悉的术语</li>
<li>暗示”问题太多，栈溢出了”</li>
<li>容易记忆和传播</li>
</ol>
<h2 id="10-为什么叫”Git”？"><a href="#10-为什么叫”Git”？" class="headerlink" title="10. 为什么叫”Git”？"></a>10. 为什么叫”Git”？</h2><p>Git是一个分布式版本控制系统。</p>
<h3 id="命名来源-3"><a href="#命名来源-3" class="headerlink" title="命名来源"></a>命名来源</h3><p>Linus Torvalds（Linux的创始人）在2005年创建了Git。他选择这个名字是因为：</p>
<ol>
<li>“Git”在英语俚语中是”愚蠢的人”的意思</li>
<li>Linus自嘲地说：”I’m an egotistical bastard, and I name all my projects after myself. First ‘Linux’, now ‘Git’.”</li>
<li>但实际上，”Git”可能是”Global Information Tracker”的缩写</li>
</ol>
<h3 id="有趣的事实-1"><a href="#有趣的事实-1" class="headerlink" title="有趣的事实"></a>有趣的事实</h3><p>Git的logo是一只章鱼猫（Octocat），这是GitHub的吉祥物。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些技术冷知识可能不会直接影响你的代码，但它们能让你：</p>
<ol>
<li><strong>理解历史</strong>：了解技术术语的来源</li>
<li><strong>加深理解</strong>：对编程概念有更深的认识</li>
<li><strong>增加趣味</strong>：让编程变得更有趣</li>
<li><strong>扩展知识</strong>：了解技术背后的故事</li>
</ol>
<hr>
<p><strong>思考</strong>：技术不仅仅是代码，还有背后的历史、文化和故事。了解这些”冷知识”，能让我们的技术之路更加丰富多彩（而且可以冷死朋友哈哈哈）。</p>
<p>如果你还知道其他有趣的技术冷知识，欢迎分享！毕竟学习路上，有趣一点总是好的 😊</p>
]]></content>
      <categories>
        <category>随便说说</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>用户中心项目总结：从 0 到 1 的完整实践</title>
    <url>/2024/11/29/2024-11-29-user-center-project-summary/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我花了大约 3 周时间完成了我的第一个完整后端项目——用户中心系统。作为一个大二学生，这个项目让我从”只会写 Hello World”到能够独立完成一个前后端分离的系统。虽然项目还没部署，代码也还有很多可以优化的地方，但这个过程让我学到了很多。今天想和大家分享一下我为什么选择这个项目，以及整个开发过程中的思考和收获。</p>
<h2 id="为什么选择用户中心项目？"><a href="#为什么选择用户中心项目？" class="headerlink" title="为什么选择用户中心项目？"></a>为什么选择用户中心项目？</h2><h3 id="1-从”看到”到”想做”"><a href="#1-从”看到”到”想做”" class="headerlink" title="1. 从”看到”到”想做”"></a>1. 从”看到”到”想做”</h3><p>其实最开始我并没有明确的项目方向。那段时间在网上刷到很多类似的项目教程，比如”从零开始搭建用户系统”、”Spring Boot 实战项目”之类的。看多了之后，我发现用户中心项目有几个特点特别适合我这种初学者：</p>
<ul>
<li><strong>功能明确</strong>：注册、登录、信息管理，这些功能我作为用户每天都在用，理解起来不费劲</li>
<li><strong>技术栈常见</strong>：Spring Boot + MySQL + Redis，这些技术网上资料多，遇到问题容易找到解决方案</li>
<li><strong>复杂度适中</strong>：不会太简单（比如只做个计算器），也不会太复杂（比如电商系统），正好适合练手</li>
</ul>
<p>所以我就决定：就做这个了！</p>
<h3 id="2-软件工程导论的启发"><a href="#2-软件工程导论的启发" class="headerlink" title="2. 软件工程导论的启发"></a>2. 软件工程导论的启发</h3><p>这学期我们开了《软件工程导论》这门课，虽然理论居多，但让我知道了做项目不是直接写代码，而是要先分析需求、设计架构、画数据库表、定义接口…这些步骤。</p>
<p>所以我想按照课程里学到的方法，一步步来：</p>
<ol>
<li><strong>需求分析</strong>：先想清楚要做什么功能</li>
<li><strong>技术选型</strong>：选什么框架、什么数据库</li>
<li><strong>架构设计</strong>：系统怎么分层，模块怎么划分</li>
<li><strong>数据库设计</strong>：表结构怎么设计，字段怎么定义</li>
<li><strong>API 设计</strong>：接口路径、参数、返回值</li>
<li><strong>编码实现</strong>：把设计变成代码</li>
<li><strong>测试优化</strong>：跑通功能，优化性能</li>
</ol>
<p>虽然最后做的时候还是踩了很多坑，但有了这个思路，至少不会完全不知道从哪开始。</p>
<h2 id="项目流程回顾"><a href="#项目流程回顾" class="headerlink" title="项目流程回顾"></a>项目流程回顾</h2><h3 id="1-需求分析阶段"><a href="#1-需求分析阶段" class="headerlink" title="1. 需求分析阶段"></a>1. 需求分析阶段</h3><p>最开始我花了两天时间梳理需求。虽然用户中心听起来简单，但真要写下来，还是有不少细节要考虑：</p>
<p><strong>核心功能</strong>：</p>
<ul>
<li><strong>用户注册</strong>：账户密码校验、重复检查（用户名、邮箱、手机号不能重复）</li>
<li><strong>用户登录</strong>：身份验证、登录态管理（Token 机制）</li>
<li><strong>用户信息管理</strong>：查看、修改个人信息</li>
<li><strong>用户管理</strong>（管理员功能）：查询用户列表、修改用户信息、删除用户</li>
<li><strong>权限控制</strong>：区分普通用户和管理员，不同角色能访问的接口不同</li>
</ul>
<p><strong>非功能需求</strong>：</p>
<ul>
<li>密码要加密存储（不能明文）</li>
<li>登录态要支持多端（PC、手机都能登录）</li>
<li>接口要统一返回格式，方便前端处理</li>
<li>异常要统一处理，不能直接返回堆栈信息</li>
</ul>
<h3 id="2-技术选型阶段"><a href="#2-技术选型阶段" class="headerlink" title="2. 技术选型阶段"></a>2. 技术选型阶段</h3><p>选技术的时候我主要考虑两个因素：<strong>学习成本</strong>和<strong>资料丰富度</strong>。毕竟我是自学，如果还选个冷门技术，遇到问题找不到资料就很麻烦。</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>技术选择</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>后端框架</td>
<td>Spring Boot</td>
<td>上手快，生态完善，网上教程多</td>
</tr>
<tr>
<td>数据库</td>
<td>MySQL</td>
<td>关系型数据库，适合存储用户信息，学习成本低</td>
</tr>
<tr>
<td>ORM</td>
<td>MyBatis-Plus</td>
<td>简化 CRUD 操作，自动生成代码，减少重复工作</td>
</tr>
<tr>
<td>登录态管理</td>
<td>Redis + Token</td>
<td>支持分布式，可主动失效，比 Session 灵活</td>
</tr>
<tr>
<td>前端</td>
<td>React + Ant Design</td>
<td>组件丰富，适合做管理系统界面</td>
</tr>
<tr>
<td>密码加密</td>
<td>BCrypt</td>
<td>安全性高，Spring Security 内置支持</td>
</tr>
</tbody></table>
<h3 id="3-架构设计阶段"><a href="#3-架构设计阶段" class="headerlink" title="3. 架构设计阶段"></a>3. 架构设计阶段</h3><p>虽然项目不大，但我还是简单画了一下架构图（用 draw.io 画的，比较简单）：</p>
<p><img src="/img/ahzUserhub-archDiagram.png" alt="系统架构示意图"></p>
<p><strong>分层设计</strong>：</p>
<ul>
<li><strong>Controller 层</strong>：接收 HTTP 请求，参数校验，返回统一格式的响应</li>
<li><strong>Service 层</strong>：业务逻辑处理，比如登录验证、密码加密、Token 生成</li>
<li><strong>Mapper 层</strong>：数据库 CRUD 操作，使用 MyBatis-Plus 简化</li>
</ul>
<p><strong>关键组件</strong>：</p>
<ul>
<li><strong>拦截器</strong>：统一处理 Token 验证、权限校验</li>
<li><strong>全局异常处理器</strong>：统一处理异常，返回友好错误信息</li>
<li><strong>工具类</strong>：Token 生成、密码加密、用户上下文（ThreadLocal）</li>
</ul>
<h3 id="4-数据库设计阶段"><a href="#4-数据库设计阶段" class="headerlink" title="4. 数据库设计阶段"></a>4. 数据库设计阶段</h3><p>数据库设计我花了不少时间，因为这是第一次自己设计表结构。我参考了一些开源项目的设计，也看了很多数据库设计的文章（后来我还专门写了一篇<a href="/2024/11/26/2024-11-26-user-center-database-design/">《用户中心项目的数据库设计：常见问题与解决方案》</a>来总结）。</p>
<p><strong>核心表设计</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户表（核心表）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `user_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `password_hash` <span class="type">CHAR</span>(<span class="number">60</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;密码哈希(bcrypt)&#x27;</span>,</span><br><span class="line">  `user_role` ENUM(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;user&#x27;</span> COMMENT <span class="string">&#x27;角色&#x27;</span>,</span><br><span class="line">  `status` ENUM(<span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;banned&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;inactive&#x27;</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  `created_at` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `is_delete` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标记&#x27;</span>,</span><br><span class="line">  INDEX `idx_email` (`email`),</span><br><span class="line">  INDEX `idx_phone` (`phone`)</span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户基本信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设计考虑</strong>：</p>
<ul>
<li>用 <code>UNIQUE</code> 保证用户名、邮箱、手机号唯一</li>
<li>给邮箱、手机号建索引，登录时查询快</li>
<li>用 <code>ENUM</code> 限制角色和状态的值，避免脏数据</li>
<li>用逻辑删除（<code>is_delete</code>）而不是物理删除，数据可以恢复</li>
</ul>
<h3 id="5-API-设计阶段"><a href="#5-API-设计阶段" class="headerlink" title="5. API 设计阶段"></a>5. API 设计阶段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户相关接口：</span><br><span class="line">POST   /api/user/register          # 用户注册</span><br><span class="line">POST   /api/user/login              # 用户登录</span><br><span class="line">GET    /api/user/getInfo            # 获取当前用户信息</span><br><span class="line">POST   /api/user/updateInfo         # 更新用户信息</span><br><span class="line">POST   /api/user/logout             # 退出登录</span><br><span class="line"></span><br><span class="line">管理员接口：</span><br><span class="line">GET    /api/admin/getUserList       # 获取用户列表</span><br><span class="line">GET    /api/admin/getUserById       # 获取用户详情</span><br><span class="line">POST   /api/admin/updateUser        # 更新用户信息</span><br><span class="line">POST   /api/admin/deleteUser        # 删除用户</span><br></pre></td></tr></table></figure>

<p>现在回头看，接口设计确实有很多问题：</p>
<ul>
<li><strong>路径命名不统一</strong>：有些用层级结构（<code>/api/user/register</code>），有些用动词+名词（<code>/api/admin/getUserList</code>）</li>
<li><strong>HTTP 方法用得不对</strong>：更新和删除应该用 PUT 和 DELETE，但我都用 POST 了</li>
<li><strong>参数传递方式混乱</strong>：<code>getUserById</code> 用查询参数传 ID，<code>updateUser</code> 和 <code>deleteUser</code> 又在请求体里传 userId，一点都不统一</li>
<li><strong>GET 请求传参不规范</strong>：<code>getUserById</code> 应该用路径参数 <code>/api/admin/user/&#123;id&#125;</code> 更规范</li>
</ul>
<p>不过当时能跑起来就行，后面我应该会写一篇关于学到的 RESTful API 设计方法。</p>
<p><strong>统一返回格式</strong>：<br>唯一做得比较规范的是统一返回格式，所有接口都返回 <code>Result&lt;T&gt;</code> 格式，这样前端处理起来方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,           <span class="comment">// 0 表示成功，非 0 表示失败</span></span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;...&#125;,       <span class="comment">// 数据</span></span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;ok&quot;</span>      <span class="comment">// 消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-开发实现阶段"><a href="#6-开发实现阶段" class="headerlink" title="6. 开发实现阶段"></a>6. 开发实现阶段</h3><p>这个阶段是最痛苦的，也是收获最多的。我遇到了很多问题，也解决了很多问题：</p>
<p><strong>问题 1：密码安全存储</strong></p>
<p>最开始我直接把密码存到数据库，后来意识到安全问题，改成了 BCrypt 加密。这个过程我专门写了一篇文章记录（见<a href="/2024/11/15/2024-11-15-password-security/">《用户中心项目踩坑记 1：密码加密那些事儿》</a>）。</p>
<p><strong>问题 2：登录态管理</strong></p>
<p>最开始用 Session，结果刷新页面就丢失，多端也无法共享。后来改成 Redis + Token 方案，解决了这些问题。这个过程我也写了文章（见<a href="/2024/11/20/2024-11-20-login-session/">《用户中心项目踩坑记 2：登录态管理的那些坑》</a>）。</p>
<p><strong>问题 3：跨域问题</strong></p>
<p>前后端分离开发，前端运行在 <code>localhost:3000</code>，后端运行在 <code>localhost:8080</code>，浏览器会报跨域错误。我通过配置 CORS 解决了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题 4：权限控制</strong></p>
<p>普通用户和管理员能访问的接口不同，我通过拦截器实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                             HttpServletResponse response, </span></span><br><span class="line"><span class="params">                             Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 验证 Token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> tokenUtils.verifyToken(token);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 权限校验（管理员接口需要 admin 角色）</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().startsWith(<span class="string">&quot;/api/admin&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(user.getUserRole())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserContext.set(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-测试与优化阶段"><a href="#7-测试与优化阶段" class="headerlink" title="7. 测试与优化阶段"></a>7. 测试与优化阶段</h3><p><strong>单元测试</strong>：<br>虽然测试写得不多，但至少给核心接口写了测试用例，比如登录、注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LoginRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequest</span>();</span><br><span class="line">        request.setAccount(<span class="string">&quot;test@example.com&quot;</span>);</span><br><span class="line">        request.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Result&lt;LoginResponse&gt; result = userController.login(request);</span><br><span class="line">        assertEquals(<span class="number">0</span>, result.getCode());</span><br><span class="line">        assertNotNull(result.getData().getToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能优化</strong>：</p>
<ul>
<li>给用户表的邮箱、手机号字段建了索引，登录查询快了很多</li>
<li>登录成功后把用户信息存到 Redis，减少数据库查询</li>
</ul>
<p><strong>异常处理</strong>：<br>写了全局异常处理器，统一处理异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;系统繁忙，请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心技术实现"><a href="#核心技术实现" class="headerlink" title="核心技术实现"></a>核心技术实现</h2><h3 id="1-通用返回结果封装"><a href="#1-通用返回结果封装" class="headerlink" title="1. 通用返回结果封装"></a>1. 通用返回结果封装</h3><p>所有接口都返回统一的 <code>Result&lt;T&gt;</code> 格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;        <span class="comment">// 业务状态码：0 表示成功，非 0 表示失败</span></span><br><span class="line">    <span class="keyword">private</span> T data;          <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">private</span> String message;  <span class="comment">// 消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.setCode(<span class="number">0</span>);</span><br><span class="line">        result.setData(data);</span><br><span class="line">        result.setMessage(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.setCode(<span class="number">500</span>);</span><br><span class="line">        result.setData(<span class="literal">null</span>);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Token-工具类"><a href="#2-Token-工具类" class="headerlink" title="2. Token 工具类"></a>2. Token 工具类</h3><p>基于 Redis 的 Token 管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 Token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;USER_TOKEN:&quot;</span> + UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储 Token 和用户信息（2小时过期）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">storeToken</span><span class="params">(String token, UserDTO user)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(</span><br><span class="line">            token,</span><br><span class="line">            JSON.toJSONString(user),</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            TimeUnit.HOURS</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 Token 并自动续期</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">verifyToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(token);</span><br><span class="line">        <span class="keyword">if</span> (userJson == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证成功后自动续期</span></span><br><span class="line">        redisTemplate.expire(token, <span class="number">2</span>, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(userJson, UserDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-用户上下文（ThreadLocal）"><a href="#3-用户上下文（ThreadLocal）" class="headerlink" title="3. 用户上下文（ThreadLocal）"></a>3. 用户上下文（ThreadLocal）</h3><p>方便在 Service 层获取当前登录用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(UserDTO user)</span> &#123;</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        userHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="收获与反思"><a href="#收获与反思" class="headerlink" title="收获与反思"></a>收获与反思</h2><h3 id="学到的技术"><a href="#学到的技术" class="headerlink" title="学到的技术"></a>学到的技术</h3><ol>
<li><strong>Spring Boot 核心功能</strong>：注解、配置、拦截器、异常处理</li>
<li><strong>MyBatis-Plus</strong>：简化数据库操作，自动生成代码</li>
<li><strong>Redis</strong>：缓存、Token 存储、分布式支持</li>
<li><strong>前后端分离开发</strong>：接口设计、跨域处理、Token 传递</li>
<li><strong>数据库设计</strong>：表结构设计、索引优化、逻辑删除</li>
</ol>
<h3 id="不足与改进"><a href="#不足与改进" class="headerlink" title="不足与改进"></a>不足与改进</h3><ol>
<li><strong>测试覆盖不够</strong>：只写了核心接口的测试，边界情况考虑不全</li>
<li><strong>代码复用性</strong>：部分逻辑存在冗余，可以提取成公共方法</li>
<li><strong>接口限流</strong>：没有实现限流，高并发场景下可能出问题</li>
<li><strong>日志记录</strong>：日志记录不够完善，出问题时排查困难</li>
<li><strong>安全性</strong>：虽然用了 BCrypt 和 Token，但还有很多安全措施没做（比如接口限流、防 SQL 注入等）</li>
</ol>
<h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><p>虽然项目基本功能都实现了，但还有很多可以改进的地方：</p>
<ol>
<li><p><strong>功能扩展</strong>：</p>
<ul>
<li>接入短信验证码，增强注册安全性</li>
<li>实现用户头像上传功能</li>
<li>添加用户登录日志，方便分析异常登录</li>
</ul>
</li>
<li><p><strong>技术提升</strong>：</p>
<ul>
<li>学习 Docker，把项目容器化</li>
<li>学习 Nginx，做反向代理和负载均衡</li>
<li>把项目部署到云服务器，让其他人也能访问</li>
</ul>
</li>
<li><p><strong>代码优化</strong>：</p>
<ul>
<li>提高测试覆盖率</li>
<li>优化代码结构，提高复用性</li>
<li>接入接口限流，防止恶意请求</li>
</ul>
</li>
</ol>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>作为第一个完整项目，过程虽然磕磕绊绊，但收获远超预期。从最初连数据库连接都配置不好，到现在能独立解决加密、登录态、跨域等问题，真切感受到了”实践”的力量。</p>
<p>这个项目让我明白，<strong>理论很重要，但实践更关键</strong>。看再多教程，不如自己动手做一遍。遇到问题、解决问题、总结经验，这个过程让我成长了很多。</p>
<p>虽然项目还没部署，代码也还有很多可以优化的地方，但至少我迈出了第一步。路还很长，继续加油！</p>
<hr>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>这个用户中心项目系列的其他文章：</p>
<ul>
<li><a href="/2024/11/15/2024-11-15-password-security/">用户中心项目踩坑记 1：密码加密那些事儿</a></li>
<li><a href="/2024/11/20/2024-11-20-login-session/">用户中心项目踩坑记 2：登录态管理的那些坑</a></li>
<li><a href="/2024/11/26/2024-11-26-user-center-database-design/">用户中心项目的数据库设计：常见问题与解决方案</a></li>
</ul>
]]></content>
      <categories>
        <category>后端开发思考</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Spring Boot</tag>
        <tag>用户中心</tag>
      </tags>
  </entry>
</search>
